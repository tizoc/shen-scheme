"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V1186 V1187) (compile (lambda X (shen.<define> X)) (cons V1186 V1187) (lambda X (shen.shen-syntax-error V1186 X))))

(defun shen.shen-syntax-error (V1190 V1191) (simple-error (cn "syntax error in " (shen.app V1190 (cn " here:

 " (shen.app (shen.next-50 50 V1191) "
" shen.a)) shen.a))))

(defun shen.<define> (V1193) (let YaccParse (let Parse_shen.<name> (shen.<name> V1193) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1193) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1195) (if (cons? (hd V1195)) (let Parse_X (hd (hd V1195)) (shen.pair (hd (shen.pair (tl (hd V1195)) (shen.hdtl V1195))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1197) (element? V1197 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1199) (if (and (cons? (hd V1199)) (= { (hd (hd V1199)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1199)) (shen.hdtl V1199))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V1201) (cond ((and (cons? V1201) (and (cons? (tl V1201)) (and (= --> (hd (tl V1201))) (and (cons? (tl (tl V1201))) (and (cons? (tl (tl (tl V1201)))) (= --> (hd (tl (tl (tl V1201)))))))))) (shen.curry-type (cons (hd V1201) (cons --> (cons (tl (tl V1201)) ()))))) ((and (cons? V1201) (and (cons? (tl V1201)) (and (= * (hd (tl V1201))) (and (cons? (tl (tl V1201))) (and (cons? (tl (tl (tl V1201)))) (= * (hd (tl (tl (tl V1201)))))))))) (shen.curry-type (cons (hd V1201) (cons * (cons (tl (tl V1201)) ()))))) ((cons? V1201) (map (lambda Z (shen.curry-type Z)) V1201)) (true V1201)))

(defun shen.<signature-help> (V1203) (let YaccParse (if (cons? (hd V1203)) (let Parse_X (hd (hd V1203)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1203)) (shen.hdtl V1203))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1203) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1205) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1205) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1205) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1207) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1207) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1207) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1207) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1207) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1210 V1211) (if (V1210 V1211) (fail) V1211))

(defun shen.succeeds? (V1217) (cond ((= V1217 (fail)) false) (true true)))

(defun shen.<patterns> (V1219) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1219) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1219) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1226) (let YaccParse (if (and (cons? (hd V1226)) (cons? (hd (hd V1226)))) (if (and (cons? (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (= @p (hd (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (shen.hdtl (shen.pair (hd (hd V1226)) (hd (tl V1226)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1226)) (hd (tl V1226)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1226)) (cons? (hd (hd V1226)))) (if (and (cons? (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (= cons (hd (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (shen.hdtl (shen.pair (hd (hd V1226)) (hd (tl V1226)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1226)) (hd (tl V1226)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1226)) (cons? (hd (hd V1226)))) (if (and (cons? (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (= @v (hd (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (shen.hdtl (shen.pair (hd (hd V1226)) (hd (tl V1226)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1226)) (hd (tl V1226)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1226)) (cons? (hd (hd V1226)))) (if (and (cons? (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (= @s (hd (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (shen.hdtl (shen.pair (hd (hd V1226)) (hd (tl V1226)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1226)) (hd (tl V1226)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1226)) (cons? (hd (hd V1226)))) (if (and (cons? (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (= vector (hd (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (shen.hdtl (shen.pair (hd (hd V1226)) (hd (tl V1226))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V1226)) (hd (tl V1226))))) (shen.hdtl (shen.pair (hd (hd V1226)) (hd (tl V1226))))))))) (shen.pair (hd (shen.pair (tl (hd V1226)) (hd (tl V1226)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1226)) (let Parse_X (hd (hd V1226)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1226)) (shen.hdtl V1226))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1226) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1228) (simple-error (shen.app V1228 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1230) (let YaccParse (if (cons? (hd V1230)) (let Parse_X (hd (hd V1230)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V1230)) (shen.hdtl V1230))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1230)) (let Parse_X (hd (hd V1230)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V1230)) (shen.hdtl V1230))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1232) (let Parse_shen.<pattern> (shen.<pattern> V1232) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1234) (let Parse_shen.<pattern> (shen.<pattern> V1234) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1236) (if (cons? (hd V1236)) (let Parse_X (hd (hd V1236)) (shen.pair (hd (shen.pair (tl (hd V1236)) (shen.hdtl V1236))) Parse_X)) (fail)))

(defun shen.<guard> (V1238) (if (cons? (hd V1238)) (let Parse_X (hd (hd V1238)) (shen.pair (hd (shen.pair (tl (hd V1238)) (shen.hdtl V1238))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1241 V1242) (let Lambda+ (shen.compile_to_lambda+ V1241 V1242) (let KL (shen.compile_to_kl V1241 Lambda+) (let Record (shen.record-source V1241 KL) KL))))

(defun shen.record-source (V1247 V1248) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1247 shen.source V1248 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1251 V1252) (let Arity (shen.aritycheck V1251 V1252) (let UpDateSymbolTable (shen.update-symbol-table V1251 Arity) (let Free (map (lambda Rule (shen.free_variable_check V1251 Rule)) V1252) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1252) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1255 V1256) (set shen.*symbol-table* (shen.update-symbol-table-h V1255 V1256 (value shen.*symbol-table*) ())))

(defun shen.update-symbol-table-h (V1264 V1265 V1266 V1267) (cond ((= () V1266) (let NewEntry (cons V1264 (eval-kl (shen.lambda-form V1264 V1265))) (cons NewEntry V1267))) ((and (cons? V1266) (and (cons? (hd V1266)) (= (hd (hd V1266)) V1264))) (let ChangedEntry (cons (hd (hd V1266)) (eval-kl (shen.lambda-form (hd (hd V1266)) V1265))) (append (tl V1266) (cons ChangedEntry V1267)))) ((cons? V1266) (shen.update-symbol-table-h V1264 V1265 (tl V1266) (cons (hd V1266) V1267))) (true (shen.f_error shen.update-symbol-table-h))))

(defun shen.free_variable_check (V1270 V1271) (cond ((and (cons? V1271) (and (cons? (tl V1271)) (= () (tl (tl V1271))))) (let Bound (shen.extract_vars (hd V1271)) (let Free (shen.extract_free_vars Bound (hd (tl V1271))) (shen.free_variable_warnings V1270 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1273) (cond ((variable? V1273) (cons V1273 ())) ((cons? V1273) (union (shen.extract_vars (hd V1273)) (shen.extract_vars (tl V1273)))) (true ())))

(defun shen.extract_free_vars (V1285 V1286) (cond ((and (cons? V1286) (and (cons? (tl V1286)) (and (= () (tl (tl V1286))) (= (hd V1286) protect)))) ()) ((and (variable? V1286) (not (element? V1286 V1285))) (cons V1286 ())) ((and (cons? V1286) (and (= lambda (hd V1286)) (and (cons? (tl V1286)) (and (cons? (tl (tl V1286))) (= () (tl (tl (tl V1286)))))))) (shen.extract_free_vars (cons (hd (tl V1286)) V1285) (hd (tl (tl V1286))))) ((and (cons? V1286) (and (= let (hd V1286)) (and (cons? (tl V1286)) (and (cons? (tl (tl V1286))) (and (cons? (tl (tl (tl V1286)))) (= () (tl (tl (tl (tl V1286)))))))))) (union (shen.extract_free_vars V1285 (hd (tl (tl V1286)))) (shen.extract_free_vars (cons (hd (tl V1286)) V1285) (hd (tl (tl (tl V1286))))))) ((cons? V1286) (union (shen.extract_free_vars V1285 (hd V1286)) (shen.extract_free_vars V1285 (tl V1286)))) (true ())))

(defun shen.free_variable_warnings (V1291 V1292) (cond ((= () V1292) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1291 (cn ": " (shen.app (shen.list_variables V1292) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1294) (cond ((and (cons? V1294) (= () (tl V1294))) (cn (str (hd V1294)) ".")) ((cons? V1294) (cn (str (hd V1294)) (cn ", " (shen.list_variables (tl V1294))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1296) (cond ((and (cons? V1296) (and (cons? (tl V1296)) (and (= () (tl (tl V1296))) (= (hd V1296) protect)))) (shen.strip-protect (hd (tl V1296)))) ((cons? V1296) (map (lambda Z (shen.strip-protect Z)) V1296)) (true V1296)))

(defun shen.linearise (V1298) (cond ((and (cons? V1298) (and (cons? (tl V1298)) (= () (tl (tl V1298))))) (shen.linearise_help (shen.flatten (hd V1298)) (hd V1298) (hd (tl V1298)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1300) (cond ((= () V1300) ()) ((cons? V1300) (append (shen.flatten (hd V1300)) (shen.flatten (tl V1300)))) (true (cons V1300 ()))))

(defun shen.linearise_help (V1304 V1305 V1306) (cond ((= () V1304) (cons V1305 (cons V1306 ()))) ((cons? V1304) (if (and (variable? (hd V1304)) (element? (hd V1304) (tl V1304))) (let Var (gensym (hd V1304)) (let NewAction (cons where (cons (cons = (cons (hd V1304) (cons Var ()))) (cons V1306 ()))) (let NewPatts (shen.linearise_X (hd V1304) Var V1305) (shen.linearise_help (tl V1304) NewPatts NewAction)))) (shen.linearise_help (tl V1304) V1305 V1306))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1319 V1320 V1321) (cond ((= V1321 V1319) V1320) ((cons? V1321) (let L (shen.linearise_X V1319 V1320 (hd V1321)) (if (= L (hd V1321)) (cons (hd V1321) (shen.linearise_X V1319 V1320 (tl V1321))) (cons L (tl V1321))))) (true V1321)))

(defun shen.aritycheck (V1324 V1325) (cond ((and (cons? V1325) (and (cons? (hd V1325)) (and (cons? (tl (hd V1325))) (and (= () (tl (tl (hd V1325)))) (= () (tl V1325)))))) (do (shen.aritycheck-action (hd (tl (hd V1325)))) (shen.aritycheck-name V1324 (arity V1324) (length (hd (hd V1325)))))) ((and (cons? V1325) (and (cons? (hd V1325)) (and (cons? (tl (hd V1325))) (and (= () (tl (tl (hd V1325)))) (and (cons? (tl V1325)) (and (cons? (hd (tl V1325))) (and (cons? (tl (hd (tl V1325)))) (= () (tl (tl (hd (tl V1325)))))))))))) (if (= (length (hd (hd V1325))) (length (hd (hd (tl V1325))))) (do (shen.aritycheck-action (hd (tl (hd V1325)))) (shen.aritycheck V1324 (tl V1325))) (simple-error (cn "arity error in " (shen.app V1324 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1338 V1339 V1340) (cond ((= -1 V1339) V1340) ((= V1340 V1339) V1340) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1338 " can cause errors.
" shen.a)) (stoutput)) V1340))))

(defun shen.aritycheck-action (V1346) (cond ((cons? V1346) (do (shen.aah (hd V1346) (tl V1346)) (map (lambda Y (shen.aritycheck-action Y)) V1346))) (true shen.skip)))

(defun shen.aah (V1349 V1350) (let Arity (arity V1349) (let Len (length V1350) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1349 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1352) (cond ((and (cons? V1352) (and (cons? (tl V1352)) (= () (tl (tl V1352))))) (shen.abstraction_build (hd V1352) (hd (tl V1352)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1355 V1356) (cond ((= () V1355) V1356) ((cons? V1355) (cons /. (cons (hd V1355) (cons (shen.abstraction_build (tl V1355) V1356) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1358) (cond ((= 0 V1358) ()) (true (cons (gensym V) (shen.parameters (- V1358 1))))))

(defun shen.application_build (V1361 V1362) (cond ((= () V1361) V1362) ((cons? V1361) (shen.application_build (tl V1361) (cons V1362 (cons (hd V1361) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1365 V1366) (cond ((and (cons? V1366) (and (cons? (tl V1366)) (= () (tl (tl V1366))))) (let Arity (shen.store-arity V1365 (length (hd V1366))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1366))) (let CondExpression (shen.cond-expression V1365 (hd V1366) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1365) (hd V1366)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1366) TypeTable CondExpression) CondExpression) (let KL (cons defun (cons V1365 (cons (hd V1366) (cons TypedCondExpression ())))) KL))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1372) (cond ((cons? V1372) shen.skip) (true (let FType (assoc V1372 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1383 V1384) (cond ((and (cons? V1383) (and (cons? (tl V1383)) (and (= --> (hd (tl V1383))) (and (cons? (tl (tl V1383))) (and (= () (tl (tl (tl V1383)))) (cons? V1384)))))) (if (variable? (hd V1383)) (shen.typextable (hd (tl (tl V1383))) (tl V1384)) (cons (cons (hd V1384) (hd V1383)) (shen.typextable (hd (tl (tl V1383))) (tl V1384))))) (true ())))

(defun shen.assign-types (V1388 V1389 V1390) (cond ((and (cons? V1390) (and (= let (hd V1390)) (and (cons? (tl V1390)) (and (cons? (tl (tl V1390))) (and (cons? (tl (tl (tl V1390)))) (= () (tl (tl (tl (tl V1390)))))))))) (cons let (cons (hd (tl V1390)) (cons (shen.assign-types V1388 V1389 (hd (tl (tl V1390)))) (cons (shen.assign-types (cons (hd (tl V1390)) V1388) V1389 (hd (tl (tl (tl V1390))))) ()))))) ((and (cons? V1390) (and (= lambda (hd V1390)) (and (cons? (tl V1390)) (and (cons? (tl (tl V1390))) (= () (tl (tl (tl V1390)))))))) (cons lambda (cons (hd (tl V1390)) (cons (shen.assign-types (cons (hd (tl V1390)) V1388) V1389 (hd (tl (tl V1390)))) ())))) ((and (cons? V1390) (= cond (hd V1390))) (cons cond (map (lambda Y (cons (shen.assign-types V1388 V1389 (hd Y)) (cons (shen.assign-types V1388 V1389 (hd (tl Y))) ()))) (tl V1390)))) ((cons? V1390) (let NewTable (shen.typextable (shen.get-type (hd V1390)) (tl V1390)) (cons (hd V1390) (map (lambda Y (shen.assign-types V1388 (append V1389 NewTable) Y)) (tl V1390))))) (true (let AtomType (assoc V1390 V1389) (if (cons? AtomType) (cons type (cons V1390 (cons (tl AtomType) ()))) (if (element? V1390 V1388) V1390 (shen.atom-type V1390)))))))

(defun shen.atom-type (V1392) (if (string? V1392) (cons type (cons V1392 (cons string ()))) (if (number? V1392) (cons type (cons V1392 (cons number ()))) (if (boolean? V1392) (cons type (cons V1392 (cons boolean ()))) (if (symbol? V1392) (cons type (cons V1392 (cons symbol ()))) V1392)))))

(defun shen.store-arity (V1397 V1398) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1397 arity V1398 (value *property-vector*)))))

(defun shen.reduce (V1400) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1400) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1402) (cond ((and (cons? V1402) (and (cons? (hd V1402)) (and (= /. (hd (hd V1402))) (and (cons? (tl (hd V1402))) (and (cons? (hd (tl (hd V1402)))) (and (= cons (hd (hd (tl (hd V1402))))) (and (cons? (tl (hd (tl (hd V1402))))) (and (cons? (tl (tl (hd (tl (hd V1402)))))) (and (= () (tl (tl (tl (hd (tl (hd V1402))))))) (and (cons? (tl (tl (hd V1402)))) (and (= () (tl (tl (tl (hd V1402))))) (and (cons? (tl V1402)) (= () (tl (tl V1402))))))))))))))) (do (shen.add_test (cons cons? (tl V1402))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1402))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1402)))))) (cons (shen.ebr (hd (tl V1402)) (hd (tl (hd V1402))) (hd (tl (tl (hd V1402))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1402)) ())) (cons (cons tl (tl V1402)) ())) (shen.reduce_help Application))))) ((and (cons? V1402) (and (cons? (hd V1402)) (and (= /. (hd (hd V1402))) (and (cons? (tl (hd V1402))) (and (cons? (hd (tl (hd V1402)))) (and (= @p (hd (hd (tl (hd V1402))))) (and (cons? (tl (hd (tl (hd V1402))))) (and (cons? (tl (tl (hd (tl (hd V1402)))))) (and (= () (tl (tl (tl (hd (tl (hd V1402))))))) (and (cons? (tl (tl (hd V1402)))) (and (= () (tl (tl (tl (hd V1402))))) (and (cons? (tl V1402)) (= () (tl (tl V1402))))))))))))))) (do (shen.add_test (cons tuple? (tl V1402))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1402))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1402)))))) (cons (shen.ebr (hd (tl V1402)) (hd (tl (hd V1402))) (hd (tl (tl (hd V1402))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1402)) ())) (cons (cons snd (tl V1402)) ())) (shen.reduce_help Application))))) ((and (cons? V1402) (and (cons? (hd V1402)) (and (= /. (hd (hd V1402))) (and (cons? (tl (hd V1402))) (and (cons? (hd (tl (hd V1402)))) (and (= @v (hd (hd (tl (hd V1402))))) (and (cons? (tl (hd (tl (hd V1402))))) (and (cons? (tl (tl (hd (tl (hd V1402)))))) (and (= () (tl (tl (tl (hd (tl (hd V1402))))))) (and (cons? (tl (tl (hd V1402)))) (and (= () (tl (tl (tl (hd V1402))))) (and (cons? (tl V1402)) (= () (tl (tl V1402))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1402))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1402))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1402)))))) (cons (shen.ebr (hd (tl V1402)) (hd (tl (hd V1402))) (hd (tl (tl (hd V1402))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1402)) ())) (cons (cons tlv (tl V1402)) ())) (shen.reduce_help Application))))) ((and (cons? V1402) (and (cons? (hd V1402)) (and (= /. (hd (hd V1402))) (and (cons? (tl (hd V1402))) (and (cons? (hd (tl (hd V1402)))) (and (= @s (hd (hd (tl (hd V1402))))) (and (cons? (tl (hd (tl (hd V1402))))) (and (cons? (tl (tl (hd (tl (hd V1402)))))) (and (= () (tl (tl (tl (hd (tl (hd V1402))))))) (and (cons? (tl (tl (hd V1402)))) (and (= () (tl (tl (tl (hd V1402))))) (and (cons? (tl V1402)) (= () (tl (tl V1402))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1402))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1402))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1402)))))) (cons (shen.ebr (hd (tl V1402)) (hd (tl (hd V1402))) (hd (tl (tl (hd V1402))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1402)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1402)) ())) (shen.reduce_help Application))))) ((and (cons? V1402) (and (cons? (hd V1402)) (and (= /. (hd (hd V1402))) (and (cons? (tl (hd V1402))) (and (cons? (tl (tl (hd V1402)))) (and (= () (tl (tl (tl (hd V1402))))) (and (cons? (tl V1402)) (and (= () (tl (tl V1402))) (not (variable? (hd (tl (hd V1402))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1402))) (tl V1402)))) (shen.reduce_help (hd (tl (tl (hd V1402))))))) ((and (cons? V1402) (and (cons? (hd V1402)) (and (= /. (hd (hd V1402))) (and (cons? (tl (hd V1402))) (and (cons? (tl (tl (hd V1402)))) (and (= () (tl (tl (tl (hd V1402))))) (and (cons? (tl V1402)) (= () (tl (tl V1402)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1402)) (hd (tl (hd V1402))) (hd (tl (tl (hd V1402))))))) ((and (cons? V1402) (and (= where (hd V1402)) (and (cons? (tl V1402)) (and (cons? (tl (tl V1402))) (= () (tl (tl (tl V1402)))))))) (do (shen.add_test (hd (tl V1402))) (shen.reduce_help (hd (tl (tl V1402)))))) ((and (cons? V1402) (and (cons? (tl V1402)) (= () (tl (tl V1402))))) (let Z (shen.reduce_help (hd V1402)) (if (= (hd V1402) Z) V1402 (shen.reduce_help (cons Z (tl V1402)))))) (true V1402)))

(defun shen.+string? (V1404) (cond ((= "" V1404) false) (true (string? V1404))))

(defun shen.+vector (V1406) (cond ((= V1406 (vector 0)) false) (true (vector? V1406))))

(defun shen.ebr (V1420 V1421 V1422) (cond ((= V1422 V1421) V1420) ((and (cons? V1422) (and (= /. (hd V1422)) (and (cons? (tl V1422)) (and (cons? (tl (tl V1422))) (and (= () (tl (tl (tl V1422)))) (> (occurrences V1421 (hd (tl V1422))) 0)))))) V1422) ((and (cons? V1422) (and (= lambda (hd V1422)) (and (cons? (tl V1422)) (and (cons? (tl (tl V1422))) (and (= () (tl (tl (tl V1422)))) (> (occurrences V1421 (hd (tl V1422))) 0)))))) V1422) ((and (cons? V1422) (and (= let (hd V1422)) (and (cons? (tl V1422)) (and (cons? (tl (tl V1422))) (and (cons? (tl (tl (tl V1422)))) (and (= () (tl (tl (tl (tl V1422))))) (= (hd (tl V1422)) V1421))))))) (cons let (cons (hd (tl V1422)) (cons (shen.ebr V1420 (hd (tl V1422)) (hd (tl (tl V1422)))) (tl (tl (tl V1422))))))) ((cons? V1422) (cons (shen.ebr V1420 V1421 (hd V1422)) (shen.ebr V1420 V1421 (tl V1422)))) (true V1422)))

(defun shen.add_test (V1424) (set shen.*teststack* (cons V1424 (value shen.*teststack*))))

(defun shen.cond-expression (V1428 V1429 V1430) (let Err (shen.err-condition V1428) (let Cases (shen.case-form V1430 Err) (let EncodeChoices (shen.encode-choices Cases V1428) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1434) (cond ((and (cons? V1434) (and (cons? (hd V1434)) (and (= true (hd (hd V1434))) (and (cons? (tl (hd V1434))) (= () (tl (tl (hd V1434)))))))) (hd (tl (hd V1434)))) (true (cons cond V1434))))

(defun shen.encode-choices (V1439 V1440) (cond ((= () V1439) ()) ((and (cons? V1439) (and (cons? (hd V1439)) (and (= true (hd (hd V1439))) (and (cons? (tl (hd V1439))) (and (cons? (hd (tl (hd V1439)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1439))))) (and (cons? (tl (hd (tl (hd V1439))))) (and (= () (tl (tl (hd (tl (hd V1439)))))) (and (= () (tl (tl (hd V1439)))) (= () (tl V1439))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1439))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1440 ())) (cons shen.f_error (cons V1440 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1439) (and (cons? (hd V1439)) (and (= true (hd (hd V1439))) (and (cons? (tl (hd V1439))) (and (cons? (hd (tl (hd V1439)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1439))))) (and (cons? (tl (hd (tl (hd V1439))))) (and (= () (tl (tl (hd (tl (hd V1439)))))) (= () (tl (tl (hd V1439)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1439))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1439) V1440)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1439) (and (cons? (hd V1439)) (and (cons? (tl (hd V1439))) (and (cons? (hd (tl (hd V1439)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1439))))) (and (cons? (tl (hd (tl (hd V1439))))) (and (= () (tl (tl (hd (tl (hd V1439)))))) (= () (tl (tl (hd V1439))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1439) V1440)) ())) (cons (cons if (cons (hd (hd V1439)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1439))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1439) (and (cons? (hd V1439)) (and (cons? (tl (hd V1439))) (= () (tl (tl (hd V1439))))))) (cons (hd V1439) (shen.encode-choices (tl V1439) V1440))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1447 V1448) (cond ((= () V1447) (cons V1448 ())) ((and (cons? V1447) (and (cons? (hd V1447)) (and (cons? (hd (hd V1447))) (and (= : (hd (hd (hd V1447)))) (and (cons? (tl (hd (hd V1447)))) (and (= shen.tests (hd (tl (hd (hd V1447))))) (and (= () (tl (tl (hd (hd V1447))))) (and (cons? (tl (hd V1447))) (and (cons? (hd (tl (hd V1447)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1447))))) (and (cons? (tl (hd (tl (hd V1447))))) (and (= () (tl (tl (hd (tl (hd V1447)))))) (= () (tl (tl (hd V1447)))))))))))))))) (cons (cons true (tl (hd V1447))) (shen.case-form (tl V1447) V1448))) ((and (cons? V1447) (and (cons? (hd V1447)) (and (cons? (hd (hd V1447))) (and (= : (hd (hd (hd V1447)))) (and (cons? (tl (hd (hd V1447)))) (and (= shen.tests (hd (tl (hd (hd V1447))))) (and (= () (tl (tl (hd (hd V1447))))) (and (cons? (tl (hd V1447))) (= () (tl (tl (hd V1447)))))))))))) (cons (cons true (tl (hd V1447))) ())) ((and (cons? V1447) (and (cons? (hd V1447)) (and (cons? (hd (hd V1447))) (and (= : (hd (hd (hd V1447)))) (and (cons? (tl (hd (hd V1447)))) (and (= shen.tests (hd (tl (hd (hd V1447))))) (and (cons? (tl (hd V1447))) (= () (tl (tl (hd V1447))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1447))))) (tl (hd V1447))) (shen.case-form (tl V1447) V1448))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1450) (cond ((and (cons? V1450) (= () (tl V1450))) (hd V1450)) ((cons? V1450) (cons and (cons (hd V1450) (cons (shen.embed-and (tl V1450)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1452) (cons true (cons (cons shen.f_error (cons V1452 ())) ())))

(defun shen.sys-error (V1454) (simple-error (cn "system function " (shen.app V1454 ": unexpected argument
" shen.a))))



